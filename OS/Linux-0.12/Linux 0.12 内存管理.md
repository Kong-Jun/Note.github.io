问题

- [ ] `share_page()`
- [x] 为什么内核的线性地址是线性映射

三个前提：

- 共享页目录
- 进程占据的线性地址空间为`nr * 64M`至` (nr + 1) * 64M`
- 物理地址从 0 开始

整个系统只有一个页目录，所有进程共享它。在启动阶段进行了自映射，将线性地址`0`至`16M`映射到了物理地址`0`至`16M`。进程分别占据线性地址`nr * 64M`至` (nr + 1) * 64M`，进程 0 是内核。用户进程所使用的最低线性地址是`64M`，远超`16M`，因此用户进程一定不会修改线性地址`0`至`16M`的映射关系。发生系统调用或中断时，进程进入内核态，数据段被设置到内核数据段（地址`0`），这时访问到线性地址`0`至`16M`，线性地址等于物理地址，因此可以直接访问物理地址。线性地址`0`至`16M`的映射在启动阶段就已经写死，内核不会修改它。所以在内核态下，线性地址（`0`至`16M`）一定等于物理地址，可以直接访问物理地址。

- [x] 线性地址`0`至`16M`映射到物理地址`0`至`16M`，但物理地址空间可能小于 16M，这时不会出错吗？

不会出错。内核知道物理地址空间的大小，并将用`mem_map[]`记录了每个物理页。内核只访问`mem_map[]`中记录的物理页，因此加入物理地址小于 16 M（比如说只有 4M），那么内核不会访问线性地址空间 4M 至 16 M。

- [x] `free_bucket_desc`指向一页，存放描述符静态链表。当该页的描述符用尽后，`free_bucket_desc`为`NULL`，`init_bucket_desc()`再分配一页存储描述符静态链表，前面被使用的描述符全部被释放，但是这些描述符所在的页却不会被释放（也没有指针指向它们，想释放也没办法），导致内存泄漏。

没问题，这点内存可以忽略。

- [ ] `malloc()`是内核分配函数，但是因为

- [ ] 页表放在什么位置？

  页目录在内核区，前 16 M 的页表也在内核区。16 M 至 4 G 线性地址空间的页表通过`get_free_page()`分配，因此在主内核区。

  

# 概述

## 内核的自映射



# 内存的探测

kernel/mm.h 中定义了一些物理内存管理相关的宏。

```c

```

如何判断页表不存在和页表不在内存中？

- 页表不存在，对应的页表项为 0
- 页表不在内存中，对应的页表项 PRESENT 位 为 0

# 物理内存

`get_free_page()`

`free_page()`



# 虚拟内存

`free_page_tables()`

`put_page()`	

`get_empty_page()`

`put_dirty_page()`





# 页面共享

`copy_page_tables()`

两种特殊情况：

- 从内核拷贝线性空间：因为内核只是用内核区的一部分空间，因此仅拷贝一部分地址空间以提高性能。
- 线性地址对应的物理地址位于主内存区：主内存区的物理内存需要进行管理，必须知道一个物理页映射到了多少个线性地址，因此需要修改引用计数。

`try_to_share()`

`share_page()`



# 写保护和缺页异常

`un_wp_page()`

`do_wp_page()`

系统使用写时复制的方式进行页面共享，当进程共享一个页面时，对这个页面进行写保护，这个页面被设置（设置进程的 PTE）为只读的。当进程写该页面时，发生写异常，进入中断处理函数`do_wp_page()`，`do_wp_page()`进行简单的参数正确性判断后调用`un_wp_page()`取消写保护。

`un_wp_page()`真正进行取消写保护的工作。取消写保护（写时复制）需要完成以下几个工作：设置 PTE,复制页，设置页引用计数。这一切对于虚拟内存是不可见的，内核将该虚拟页关联到了一个可以被它写的物理页。

有以下几种情况需要考虑：

- 只有一个用户进程使用该页（页地址大于`LOW_MEM`）
- 多个进程共享该页
  - 内核（小于`LOW_MEM`的内存）
  - 用户（主内存区）

当只有一个进程使用该页时，只需要将 PTE 中的 R/W 位置位;当有多个进程共享时，获取一个新的物理页，将旧页的数据复制过去，并设置 PTE 指向新页（R/W 和 P 置位），如果页在主内存区（用户进程使用），还需要递减旧页的引用计数。

>  如何根据线性地址获取对应的 PTE 地址？

可以查看`do_wp_page()`的代码，`un_wp_page()`的参数是 PTE 的地址，因此在调用`un_wp_page()`前要计算出线性地址对应的 PTE 地址，可以查看

```c
/** (address>>10) & 0xffc : 取 VPN
 *  (0xfffff000 & *((unsigned long *) ((address>>20) &0xffc))) : 取页表地址
 *  两者相加就是 PTE 的地址
 */
un_wp_page((unsigned long *)
    (((address>>10) & 0xffc) + (0xfffff000 &
    *((unsigned long *) ((address>>20) &0xffc)))));

```



# 内核内存分配函数`malloc()`

## 算法

**分裂和合并**

**空间不足时的处理**

**限制**

**可重入性**

## 并发问题的处理

- 分配时：关闭中断
- 释放时：反复判断

## 指针技巧



