-[ ] 代码模型
- 指令格式

- 设计原则：最小功能指令，通过汇编语言伪指令拓展指令集

- 大立即数的处理

- 立即数的高位和低位

- 所有立即数进行符号拓展

- 整数运算都是寄存器大小的

- 条件跳转和无条件跳转都是 PC-relative 的

- 大地址跳转 auipc jalr

- 似乎不存在间接跳转

  有的，通过基址寄存器跳转

- 数字标签：lui & addi(默认代码模型 medlow，只能方位 -2G 到 2G）代码标签：auipc & jalr

- lui 会将 64 位值截取为32位，取出 20 位值左移 12 位加载到寄存器时进行符号拓展，因此要小心符号不一致的问题

- sp 16字节对齐

- 取数据存在符号拓展和无符号拓展两种情况，因此有`ld`和`ldu`两种指令

- 条件分支比较时存在有符号和无符号两种情况，因此条件分支存在`u`版本

- 由于 S 型指令和 I 型指令编码格式中立即数只有 12 位，所以`addi`（I 型）和`ld`（S 型）等指令只能使用 12 位立即数（补码）
- 边界条件（有符号数）的便捷检测方法
- 由于 RISCV 支持压缩指令（2 字节），因此跳转指令的地址以半字（2 字节）为单位
- 条件跳转指令使用 SB 格式，立即数是 12 位，因此只能跳转到当前地址偏移 -2^11 ~ 2^11 - 1 个半字的地址
- 无条件跳转指令使用 UJ 格式，立即数是 20 位，因此只能跳转到当前地址偏移 -2 ^ 19 ~ 2 ^ 19 - 1 个半字的地址

# 寻址方式

两段四类寻址方式：

- 立即数寻址：I 型指令，12 位立即数

`addi rd, rs, imm`

`ld ds, imm(rs)`

- 寄存器寻址：R 型指令，无立即数，不访问内存

`add rd, rs1, rs2`

- 基址寻址：I 型指令，12 位立即数

`jalr rd, imm(rs)`

- PC-relative 寻址：条件分支 12 位立即数，`jal` 20 位寄存器

`bge imm`

`jal rd, imm`

立即数寻址用于内存数据的读写（写时 S 型指令），基址寻址和PC-relative 寻址用于跳转指令。可见，寻址方式和指令编码有关，比如`jal`使用 20 位立即数，所以使用特殊的编码格式;但寻址方式和指令编码是两个概念，PC-relative 寻址对应两种编码格式。

访问大地址上的数据：先计算出所在地址，存放在寄存器中，再使用`ld`（I 型）/`sd`（S 型）

跳转到大地址：先计算出所在地址，存放在寄存器中，然后使用基址寻址。



# 大立即数和

可以看到，RV64 中能使用的立即数最大是 20 位（无条件跳转），有时需要更大的立即数，我们可以利用已有指令（如`lui`，`addi`，`sll`等）在寄存器中拼接出所需位数的数字。

最常用的大立即数是 32 位立即数，然而没有办法直接使用 32 位立即数（指令总共才 32 位），可以结合`lui`（将 20 位立即数加载到寄存器的 31 ~ 12 位，低位清零）和`addi`（加 12 位立即数）在寄存器中构造一个数字。

```asm
lui r0, 974
addi r0, r0, 1280
```

这样就拼接除了一个大立即数。

如果需要 64 位立即数也使用类似的方法，比如获取 64 位数`1000_0000_0000_0000_0000_0000_0000_0000`：

```asm
mv t0, 8
slli t0, 60
```





# 乘除法拓展

# 浮点数拓展



# RVG 调用规范

将参数想象为一个逻辑上的结构体，每个参数是一个成员。

参数：

- 可变参数中的浮点数传入到整形参数寄存器中
- 结构体中的联合体中的浮点数以及结构体中数组字段中的浮点数传入到整型参数寄存器中 ？？？？？
- 小于指针大小的参数传入到对应整形参数寄存器中的低位
- 通过堆栈传递的子指针大小的参数在指针大小的参数的低地址处 ???????
- 两指针大小的参数既可以通过堆栈传递也可以通过寄存器传递。如果通过堆栈传递，他们是自然对齐的;如果通过寄存器传递，每个参数使用一对偶数编号/奇数编号寄存器。

RV32 `void foo(int, long long)`：第一个参数传递到`a0`中，第二个参数低字节传递到`a2`中，高字节传入到`a3`中，`a1`不使用

- 大于 2 指针大小的参数传递引用

- 逻辑结构体中未通过寄存器传递的参数通过堆栈传递，`sp`指向第一个未通过寄存器传递的参数

- 堆栈向低地址增长并 16 字节对齐



返回值：

- 整型返回到`a0`，`a1`，浮点数返回到`fa0`，`fa1`
- 浮点数尽在他们是单独的变量或是只包含最多两个浮点数的结构体的成员时返回到`fa0`，`fa1`中
- 其他的两指针大小的结构体返回到`a0`,`a1`中
- 大于两指针大小的结构体通过内存返回。调用者分配内存，并将指针作为被调用者的第一个参数隐式地传递给调用者（应该指用户写的参数将从`a1`开始传递）
-



