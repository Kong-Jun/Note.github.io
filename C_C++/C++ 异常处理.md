# 怎样看待异常

异常用于指示**不能在本地处理的错误 **。当函数出错，并且它无法自己处理，就抛出异常，**传播** 给上层调用者。如果错误的无法处理的，则抛出后不应该处理（终止程序，并进行堆栈展开），使用 RAII 确保资源正确回收。

异常之应该用于错误处理，不应该将其作为控制流或返回值。异常也不应该用于不可预测的情况、编码错误、条件契约被违反，这些情况应该使用`assert()`直接杀死进程，dump 后进行调试。



**疑问**：直接`assert()`不会发生资源的泄漏吗？直接抛出异常但不处理不行吗？





# 为什么要使用异常？

- 将错误检测、处理的代码和一般逻辑分离。使用异常可以在一处处理一般逻辑，集中在另一处处理错误。如果使用错误码，错误处理和一般逻辑可能会搅成一团，即"意大利面代码"。

- 调用者必须处理错误情况，否则程序终止
- 会展开堆栈（*stack wind*），清除堆栈中的对象，避免资源泄漏
- 如果没有异常，反应构造函数中发生的错误将非常困难和丑陋。不使用异常，可能需要设置一个指示是否成功的标准，并且每次构造对象都需要检测它。
- 避免使用`if`语句判断返回值，提高软件质量。`if`语句非常容易出错，避免`if`降低了潜在的错误和开发时间
- 干净、简单的错误传播机制。很多时候，一个函数会嵌套多层，并在深层的子函数中发生错误，但是只有浅层的函数有足够多的信息在处理该错误。异常提供了异常方便的错误传播机制，如果使用错误码，需要层层判断，这会增加逻辑的复杂度，提高 bug 发生的可能，降低开发速度。
- 简化 API 设计。使用异常避免了使用出参反应错误，并每次操作都进行检查。当出错时，直接抛出异常，相当于函数多了一个指示错误的返回值。

# 异常的性能

现代 C++ 使用异常大约比不不进行错误处理的代码有 3% 的性能下降。当抛出异常时才会遭致副作用，在未抛出异常时异常处理的代价极小。不使用异常也仍然有性能损失，如果使用错误码，每一次函数调用都需要判断是否出错。



# 异常与构造函数

# 异常与析构函数

# 异常类



# 如何捕捉异常

捕捉引用

异常处理函数分派器

# 异常与多态

# 准则

- 不要将异常当成另一种形式的返回码，不需要在每个可能抛出异常的函数周围进行`try`和`catch`，而应该对某个代码块进行`try`和`catch`。
- 异常应当反应错误的原因，而不是发生错误的代码段。比如一个系统有多个子系统（如 Foo, Bar），不应该设置多个“子系统异常”`FooException`、`BarException`来反应出错的代码段，这样会导致许多不必要的`try`、`catch`块。应该设置许多个反应真正错误原因的异常。
- 使用异常的类型指示错误，而不应该使用异常对象中的值指示错误。比如有多个错误，应该设置多个不同类型的异常对象，而不应该在异常对象中硬编码许多标志来指示错误类型。

# 异常安全

基本技术：

- `try`-`catch`
- 精心安排次序
- RAII

通过 RAII（**确保某种不变性**）和精心安排指令次序，可以很大程度减少`try`-`catch`块。大量的`try`-`catch`会让代码变得混乱难读，使用 RAII 和精心安排指令次序的方法更加优雅可靠。

基本原则：

- 在对象的替代品完成构造并且可以和当前对象不发生异常的进行交换前，不要销毁当前对象的任何信息
- 将资源抽象成一个类
- 总是关注构造函数、析构函数、赋值运算、迭代器操作、交换的异常安全性
- 使用 RAII 和标准库设施来实现异常安全
- 总是从构建、维护不变性的角度编写代码，避免”二段式构造“和不安全、不可靠状态
- 析构函数、交换函数不应该抛出函数
- 移动操作不应该抛出异常
- 标准库设施都实现了不同程度的异常安全性，但这依赖于用户函数符合标准库的异常安全要求
- 将操作抽象为尽量小的函数、类，并根据重要程度安排不同程度的异常安全性

对于模板和其他”细“的软件层来说，异常透明（构造函数不处理异常，仅简单抛出）常常是最好的选择。

## 异常与赋值运算符

## 标准库的异常安全性

违反标准库容器要求的异常安全保证，和违反一般的语言禁忌（如解引用空指针）的性质相同，都会致对象于不可靠的状态。

# 资源的清理

当异常被捕获时，会发生堆栈展开，但未被捕获时，是否展开堆栈是实现定义的。

如何合理的退出 C++ 代码，确保资源被清理，并且程序被置为一个安全状态需要我们认真考虑。



异常不是灵丹妙药，它有自己的问题，比如一定的性能损耗、需要良好设计，但是合理使用异常可以提高代码质量。