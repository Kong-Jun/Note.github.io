# 左值/右值

# 左值引用与右值引用

## 变量的左值/右值性与其类型无关



# 万能引用

只有发生了类型推导才算是万能引用，并且必须形如`T &&`（包含`auto &&`,`typedef`和`decltype()&&`)，`const T &&`是万能引用。

# 引用折叠

语法语法形式必须为`T &&`，`auto &&`，`typedef`，`decltype()&&`，必须发生类型推导，并且该类型是引用类型。可以说，万能引用是 C++ 推导规则和引用折叠共同作用下创造出来的。

`T &`和`T &&`作用在引用类型上时保留`const`。

# 完美转发和移动语义

完美转发不改变类型，但将恢复参数原本的左值/右值性。

移动语义不改变类型，将一个变量转化为右值。





# 总结

万能引用：

- 值类型：保留`const`，左值 ==> 左值引用，右值 ==> 右值引用，
- 引用类型：保留底层`const`，消除引用，左值（指引用） ==> 左值引用，右值（指引用）  ==> 右值引用

```c++
const int &i = 100;
auto &&r = std::move(i);   // r 的类型为 const int &&
```

`std::move()`和`std::forward<T>()`: 不修改变量类型，只修改变量的左值/右值性。`std::move()`将参数强制转换为左值，`std::forward<T>()`将参数转换为原先的左值/右值性



**auto 的陷阱**:

- auto 无法和 proxy class 正常工作，请使用`static_cast<>()`进行转换
- 当 auto 作为返回值和参数类型时相当于模板参数，不将`{}`视为`std::initializer_list`
- auto 存在版本问题，C++17 之前，`auto i {100}`中`i`可能被推导为`std::initializer_list<int>`，而 C++17 之后将其推导为`int`。