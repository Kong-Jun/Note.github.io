<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>POD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h1></div>
<ul>
<li>
<a href="POD.html#Overview">Overview</a>

<li>
<a href="POD.html#Standard layout">Standard layout</a>

<li>
<a href="POD.html#Trivial type">Trivial type</a>

<li>
<a href="POD.html#POD">POD</a>

<li>
<a href="POD.html#Example">Example</a>

<li>
<a href="POD.html#Resources">Resources</a>

</ul>

<div id="Overview"><h1 id="Overview" class="header"><a href="#Overview">Overview</a></h1></div>
<p>
C++ class aggregate data and operations(function) into single class. The most trickle problem arose from the design is that the layout of class perhaps differentiates from ordinary old struct in C. If some type is not compatible with C struct type, it can't interact with C program directly. Moreover, Many class in C++ is not memory-continuous, it can't be transfered between Internet software.
</p>

<p>
To solve this problem, C++ introduce the concept of <em>POD(plain old data)</em>. POD is a type which is compatible with C program. That is to say, The type is memory-continuous(stored continuously in memory) and C-layout-compatible(the layout of class is same with C struct/union).
</p>

<p>
After C++11, C++ has not emphasized any more. POD is defined as the type satisfies <em>standard layout</em> and <em>trivial type</em>. Trivial type is memory-continues and bitwise-copyable(can be copy using <code>memcpy()</code> and restored correctly), standard layout type is C-layout-compatible.
</p>

<div id="Standard layout"><h1 id="Standard layout" class="header"><a href="#Standard layout">Standard layout</a></h1></div>
<p>
Standard layout is the type satisfies the following restrictions:
</p>

<ul>
<li>
has <span id="Standard layout-no virtual"></span><strong id="no virtual">no virtual</strong> functions and no virtual base classes.

<li>
has the <span id="Standard layout-same"></span><strong id="same">same</strong> access control (private, protected, public) for all its <span id="Standard layout-no-static"></span><strong id="no-static">no-static</strong> data members.

<li>
only <span id="Standard layout-one"></span><strong id="one">one</strong> class can has non-static member in inheritance hierarchy. That is to say, either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members.

<li>
<span id="Standard layout-any sub-objects"></span><strong id="any sub-objects">any sub-objects</strong> (member and base class) are standard layout type.

<li>
has no base classes(include base of base ...) of the same type as its <span id="Standard layout-first"></span><strong id="first">first</strong> non-static data member.

</ul>

<p>
If class has virtual function or virtual base class, there is <em>vtpr</em>(<em>virtual table pointer</em>) in class bringing about non-compatibility with C.
</p>

<p>
For historical reasons, compiler would do some extra implicit things which modify layout of type.
</p>

<p>
It is worth noting that all restrictions only act on non-static data member.
</p>

<p>
 General say, a type is whether standard type is determined by the non-static member in class hierarchy.
</p>


<div id="Trivial type"><h1 id="Trivial type" class="header"><a href="#Trivial type">Trivial type</a></h1></div>
<p>
Trivial type is the type satisfies the following conditions:
</p>
<ul>
<li>
uses the implicitly defined(or default()) default, copy and move constructors, copy and move assignments, and destructor.

<li>
has no virtual sub-objects.

<li>
<span id="Trivial type-has no non-static data members with brace- or equal- initializers"></span><strong id="has no non-static data members with brace- or equal- initializers">has no non-static data members with brace- or equal- initializers</strong>.

<li>
its base class and non-static data members (if any) are themselves also trivial types.

</ul>

<p>
What is trivial? The answerer <em>AnT</em> in stackoverflow gives the wonderful answer as following:
</p>


<p>
	In simple words a "trivial" special member function literally means a member function that does its job in a very straightforward manner. The "straightforward manner" means different thing for different kinds of special member functions.
</p>

<p>
	For a default constructor and destructor being "trivial" means literally "do nothing at all". For copy-constructor and copy-assignment operator, being "trivial" means literally "be equivalent to simple raw memory copying" (like copy with memcpy).
</p>

<p>
	If you define a constructor yourself, it is considered non-trivial, even if it doesn't do anything, so a trivial constructor must be implicitly defined by the compiler.
</p>

<p>
	In order for a special member function to satisfy the above requirements, the class must have a very simplistic structure, it must not require any hidden initializations when an object is being created or destroyed, or any hidden additional internal manipulations when it is being copied.
</p>

<p>
	For example, if class has virtual functions, it will require some extra hidden initializations when objects of this class are being created (initialize virtual method table and such), so the constructor for this class will not qualify as trivial.
</p>

<p>
	For another example, if a class has virtual base classes, then each object of this class might contain hidden pointers that point to other parts of the very same object. Such a self-referential object cannot be copied by a simple raw memory copy routine (like memcpy). Extra manipulations will be necessary to properly re-initialize the hidden pointers in the copy. For this reason the copy constructor and copy-assignment operator for this class will not qualify as trivial.
</p>

<p>
	For obvious reasons, this requirement is recursive: all sub-objects of the class (bases and non-static members) must also have trivial constructors.
</p>

<p>
Significantly, trivial is not a synonym for <span id="Trivial type-trivially copyable"></span><strong id="trivially copyable">trivially copyable</strong>(bitwise copyable). One of the  conditions of POD is - <em>has no non-static data members with brace- or equal- initializers</em>. This resection is to guarantee the safety of <em>static initialization</em>. Obviously, whether a type can be bitwise-copyable has nothing to do with the initialization. Hence, despite a type don't satisfies the restriction of <em>has no non-static data members with brace- or equal- initializers</em>, it also can be bitwise-copyable. This feature of type is also called <em>trivial copyable</em>.
</p>

<div id="POD"><h1 id="POD" class="header"><a href="#POD">POD</a></h1></div>
<p>
As is stated above, POD is a type satisfies standard-layout and trivial simultaneously.
</p>

<p>
C++ provide various facilities(template struct in header _type_traits_) to determine the type of class. For instance, <code>std::is_trivial</code>, <code>std::is_standard_layout</code>, <code>std::is_trivial_copyable</code>,<code>std::trivial_default_constructable</code> and so on.
</p>

<div id="Example"><h1 id="Example" class="header"><a href="#Example">Example</a></h1></div>
<pre cpp>

#include &lt;iostream&gt;
#include &lt;type_traits&gt;


class A
{
    int a_val;
};

struct B : public A
{
    int b_al;
};

class virt
{
    virtual void virtual_function() = 0;
};

class C : public A
{
public:
    A a;
    int i;
    int j;
    int arr[10] = {0};
    static void foo1();
private:
    static void foo2();
};

int main()
{
    std::cout &lt;&lt; "class C is standard layout type" &lt;&lt; " " &lt;&lt; std::is_standard_layout&lt;C&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; "class C is trivial type" &lt;&lt; " " &lt;&lt; std::is_trivial&lt;C&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; "class C is POD type" &lt;&lt; " " &lt;&lt; std::is_pod&lt;C&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; "class C is trivially copyable type" &lt;&lt; " " &lt;&lt; std::is_trivially_copyable&lt;C&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; "class C is trivially default constructable type" &lt;&lt; " " &lt;&lt; std::is_trivially_default_constructible&lt;C&gt;::value &lt;&lt; std::endl;
    return 0;
}
----------------------------------------------------------------------------------------------------
class C is standard layout type 0
class C is trivial type 0
class C is POD type 0
class C is trivially copyable type 1
class C is trivially default constructable type 0
</pre>

<div id="Resources"><h1 id="Resources" class="header"><a href="#Resources">Resources</a></h1></div>
<p>
<em>AnT</em>'s wonderful answer: <a href="https://stackoverflow.com/questions/3899223/what-is-a-non-trivial-constructor-in-c">https://stackoverflow.com/questions/3899223/what-is-a-non-trivial-constructor-in-c</a>
</p>

<p>
知乎问题“什么是POD”: <a href="https://www.zhihu.com/search?type=content&amp;q=C%2B%2B%20pod">https://www.zhihu.com/search?type=content&amp;q=C%2B%2B%20pod</a>
</p>

<p>
果冻虾仁关于虚表的回答: <a href="https://www.zhihu.com/question/389546003/answer/1194780618">https://www.zhihu.com/question/389546003/answer/1194780618</a>
</p>

<p>
果冻虾仁关于虚表中 type_info 的回答: <a href="https://www.zhihu.com/question/29251261/answer/1297439131">https://www.zhihu.com/question/29251261/answer/1297439131</a>
</p>

</body>
</html>
