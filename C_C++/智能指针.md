## 智能指针

标准库提供了两种种智能指针(`shared_ptr`和`unique_ptr`)和一个伴随类(`weak_ptr`)来管理动态对象.

### 特性

* 智能指针是一个模板类,其中包含了普通指针,增加了引用计数等功能.
* 智能指针销毁对象,释放内存时默认调用delete运算符.可以定义自己的**删除器**(一个可调用对象)并传递给智能指针,从而替代默认的`delete`运算符.

### 智能指针基本操作

以下是`shared_ptr`和`unique_ptr`都支持的操作.

| 操作               | 说明                                                   |
| ------------------ | ------------------------------------------------------ |
| `shared_ptr<T> sp` | 空`shared_ptr`智能指针,能够指向类型为T的对象.          |
| `unique_ptr<T> up` | 空`unique_ptr`智能指针,能够指向类型为T的对象.          |
| `p`                | 将`p`用于条件判断.若`p`中的内置指针非`nullptr`,则为真. |
| `*p`               | 解引用`p`,得到`p`指向的对象的引用.                     |
| `p->mem`           | 成员访问.                                              |
| `p.get()`          | 返回`p`中保存的内置指针.                               |
| `swap(p1,p2)`      | 交换`p1`,`p2`中保存的内置指针.                         |

### shared_ptr类

#### 特性

* shared_ptr允许多个指针同时指向一个对象.shared_ptr可以记录有多少**智能指针**(包括当前shared_ptr)共享同一对象,这些智能指针必须**同源**(能追溯到**同一个智能指针**),称为**引用计数**.

```c++
int *q=new int(100);
shared_ptr<int> p1(q); //由q创建p1.p1引用计数为1.
shared_ptr<int> p2(q); //有q创建p2.由于p2是由q单独创建的shared_ptr,并非和p1并非来源与同一个智能指针,与p1无关.因此引用计数也为1.
shared_ptr<int> p3(p1); //由p1创建p3.p3是p1的拷贝,来自p1,与p1同源,因此p1和p3的引用计数都为2.
cout<<"p1's use_count:"<<" "<<p1.use_count()<<endl;
cout<<"p2's use_count:"<<" "<<p2.use_count()<<endl;
--------------------------------------------------------------------------------------------------------------------
输出:
p1's use_count: 2
p2's use_count: 1

```

* 当shared_ptr进行拷贝(指向同一内存的shared_ptr增加)时,与之绑定的引用计数递增;当shared_ptr销毁或指向别的对象(指向同一内存的shared_ptr减少)时,与之绑定的引用计数递减.

```c++
/* Func函数定义
shared_ptr<int> Func(shared_ptr<int> p){
    //precess;
    return p;
}
*/
shared_ptr<int> p(new int());
Func(p);
//从Func定义知:
//p传递给形参是被拷贝,引用计数递增;
//Func返回p,p被拷贝,引用计数递增;
```

* shared_ptr可以**协调对象的析构,但仅限于自身拷贝的shared_ptr**.来源于一个shared_ptr的shared_ptr有着同样的引用计数,当引用计数为0时自动销毁对象并释放内存;当多个shared_ptr指向同一个对象,但并不同源时,只要其中一个shared_ptr的计数为0,不论其他shared_ptr计数为多少,对象都会被销毁并释放内存.

```c++
//接上文代码
......
p2.reset(); //置空p2,p2引用计数为0,导致指向的对象被销毁,尽管其他shared_ptr引用计数不为0.
--------------------------------------------------------------------------------------------------------------------
//以下代码使用g++  7.4.0 ubuntu18.04.2 LTS下观察p2.reset()前后指向的对象的值.
//接最开始的代码;
......
cout<<"p2.reset()前,对象的值:"<<" "<<*q<<endl;
p2.reset(); //置空p2,p2引用计数为0,导致指向的对象被销毁,尽管其他shared_ptr引用计数不为0.
cout<<"p2.reset()后,对象的值:"<<" "<<*q<<endl;

输出:
"p2.reset()前,对象的值: 100
"p2.reset()后,对象的值: 0
--------------------------------------------------------------------------------------------------------------------
输出情况表示q指向的对象已经被销毁,至于输出*q为0是g++编译器的行为.
```

#### 特有操作

| 操作            | 说明                            |
| --------------- | ------------------------------- |
| `p.use_count()` | 返回`p`引用计数的数目.          |
| `p.unique()`    | 当`use_count`为`1`时返回`true`. |

#### 初始化

获得一个`shared_pt`r的方法有很多,总的来说分为三大类:

1. 通过调用make_shared函数.这是最安全的方式.
2. 通过拷贝另一个智能指针.
3. 通过内置指针初始化.往往与new一起使用.

| 初始化方式             | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 通过make_shared函数    | ------------------------------------------------------------------------------------------------------------------------- |
| make_shared<T>(args)   | 返回一个shared_ptr,指向一个动态分配的用args初始化的类型为T的对象.不传递参数时,对象**值初始化**. |
| 通过另一个智能指针     | ------------------------------------------------------------------------------------------------------------------------- |
| shared_ptr<T> p1(p2)   | p1是p2的拷贝.p2必须能转换为T*类型.p2的引用计数增加.          |
| shared_ptr<T> p1(p2,d) | p1是p2的拷贝.p2必须能转换为T*类型.p2的引用计数增加.并且用删除器d替代默认的delete. |
| shared_ptr<T> p1(up)   | 从unique_ptr up接管对象所有权,**置up为空**                   |
| 通过内置指针           | ------------------------------------------------------------------------------------------------------------------------- |
| shared_ptr<T> p1(q)    | 从内置指针q接管对象.q必须**指向动态分配的内存**,并且**可以转换成T*类型**. |
| shared_ptr<T> p2(q,d)  | 从内置指针q接管对象.q必须**指向动态分配的内存**,并且**可以转换成T*类型**.使用删除器d替代默认的delete. |

* 通过make_shared函数获得shared_ptr是最安全的方式.

```
shared_ptr<int> p1=make_shared<int>(); //不传递参数,值初始化.
shared_ptr<int> p2=make_shared<int>(100); //值为100.
shared_ptr<string> p3=make_shared<string>(10,'s');
```

* 通过另一个智能指针拷贝获得shared_ptr时需要注意引用计数. 

```
shared_ptr<int> p1=make_shared<int>(100); //p1引用计数为1.
shared_ptr<int> p2(p1); //p2是p1的拷贝,源自p1.p1引用计数递增为2.
```

* 接受内置指针的构造函数是**explicit**的,因此必须使用**直接初始化**.

```
shared_ptr<int> p=new int(100); //错误.构造函数是explicit的,只能直接初始化.
shared_ptr<int> p(new int(100)); //正确.
```

#### 改变一个shared_ptr

* 赋值运算可以通过另一个shared_ptr改变shared_ptr;
* 调用reset成员函数可以通过内置指针改变shared_ptr;

| 操作         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| p1=p2        | p1是shared_ptr p2的拷贝.p2引用计数递增,p1引用计数递减.       |
| p.reset()    | 将p置空,p的引用计数递减.                                     |
| p.reset(q)   | p指向内置指针q指向的对象,引用计数递减.                       |
| p.reset(q,d) | p指向内置指针q指向的对象,引用计数递减.用删除器d替代默认的delete. |

#### 注意事项

1. 注意shared_ptr的引用计数,不要混用智能指针和内置指针.

```c++
//考虑以下代码;
/* process定义
void process(shared_ptr<int> ptr){
    //使用projjjjjjjjjcess;
} //ptr离开作用域,被销毁.
*/
//正确用法:
shared_ptr<int> ptr(new int());
process(ptr); //ptr被拷贝给形参,ptr引用计数为2,然后形参被销毁,ptr引用计数为1.
int p=*ptr; //ptr引用计数为1,因此指向的对象没有被销毁.
//
//错误用法:
int *p=new int();
process(shared_ptr<int>(p)); //向process函数传递一个临时的shared_ptr,这个临时变量传递给形参后就被销毁.在函数体内形参变量引用计数为1;函数体结束后形参变量被销毁,引用计数变为0,指向的对象也被销毁.
int *q=*p; //错误,而且该错误未定义,编译器不报错.p指向的对象已经被销毁.
```

2. 不要从内置指针创建多个独立的shared_ptr

```c++
    int *q=new int(100);
    shared_ptr<int> p1(q);
    shared_ptr<int> p2(q);
    shared_ptr<int> p3(p1);
    p2.reset(); //p2原来引用计数为1,reset后引用计数为0,指向的对象被销毁.
    cout<<*q<<endl; //错误,且行为未定义,且编译器不报错.q指向的对象已经被销毁.
```

3. 使用get成员函数从只能指针返回内置指针时要慎之又慎.千万不要delete返回的指针,也不要犯前两点错误.

```c++
shared_ptr<int> p(new int(42)); //引用计数为1;
int *q=p.get();
delete q; //危险操作.此举导致只能指针p指向的对象被销毁.
{
    shared_ptr<int> p2(q); //两个独立的shared_ptr指向同意内存.
}// 程序块结束,p2被销毁,p2指向的对象被销毁,导致p1成为空悬指针.
```

### unique_ptr类(待续)

unique_ptr独占对象.

### weak_ptr类(待续)







------------------------------

# 语意

`shared_ptr`: 共享所有权

`unique_ptr`: 独占所有权

`weak_ptr`: 只共享不拥有

`shared_from_this`: 增加所有权

# 性能

# 异常安全



# 常见错误

## 创建多个所有者

## 循环引用

## 错误的引用计数

# 删除器

默认删除器:`std::default_delete<T>`

`unique_ptr`消耗最小内存、最快速度，因此删除器是类型的部分，不可动态更改。而`shared_ptr`比较灵活，内部裸指针、删除器、分配器均可动态更改。

对数组的处理

# 观察器

`get_deleter()`返回**指针**