# Debugging with GDB: Stop and Continuing

## 断点

### 断点的插入、计算

### 查看断点

### 设置断点

### 删除断点

### 开启断点

### 禁用断点

### 忽略断点

-----------------



### 条件断点

断点和观察点可以在指令后附上`if`将

### 断点命令



--------------------------





## 观察点

观察点（watchpoint）是一种特殊的断点，当被观察的表达式、变量被写入、改变、读取时暂停程序。GDB提供了三种观察点，分别对应以下三个命令：

- watch: 当被观察点被**写入**或**修改**时，暂停程序。
- awatch: access watchpoint。当观察点被**读取**或**写入**时，暂停程序。
- rwatch: read watchpoint。当观察点被**读取**时，暂停程序。

与断点相同，观察点也分为硬件观察点和软件观察点。硬件观察点需要硬件的支持（X86支持硬件观察点），额外开销很小，当有指令修改（读取、写入）观察点时，调试器能立刻发现事件的发生;软件观察点在每次表达式执行后观察观察点的值是否改变，所以开销很大，甚至可能将程序的性能降低上百倍，在表达式执行后调试器才能发现事件的发生。

软件观察点的用处比较有限，只能支持watch命令，只能检查观察点的值是否被改变，并且不支持多线程，还存在极大的额外开销。GDB优先使用硬件断点，如果使用awatch、rwatch命令但系统不支持硬件断点的话会报错。

可以使用以下命令查看、设置GDB是否允许使用硬件断点。

```
set can-use-hw-watchpoints
show cen-use-hw-watchpoints
```

观察点是特殊的断点，所有操作断点的命令都可以用于观察点，而且观察点也存在于断点的列表中。

观察点仅对程序导致的访问、修改生效，如果用户使用`print`或`call`调用函数，其中的所有观察点都会**被忽略**。

### 观察点的设置

使用以下命令设置观察点：

```
watch [-l|-location] expr [thread thread-id] [mask maskvalue]
```

- `-l|-location`：观察内存地址`expr`上的内容
- `mask maskvalue`: 内存地址掩码。当指定掩码时，默认使用`-l`选项，可以一次观察多个按位与掩码后值相同的地址上的值

- [thread thread-id]：观察点只对线程`thread-id`有效

观察点的语义是当某**表达式**被访问、修改时暂停，对常量、地址设置观察点是无用的（常量、地址不可能改变），如果要观察某个地址的内容，必须将其转换成一个变量。比如，观察地址`0xffffffff`上的内容，不能使用`watch * 0xffffffff`（地址不可能改变），应该使用`watch *(int*)0xffffffff`（将int *地址解引用）。

### 



### 观察点的作用域

非 static 的局部变量在离开作用域后就会被销毁。相应地，对局部变量设置的观察点也会在离开作用域后被销毁。如果被观察的表达式中有变量离开了作用域，该观察点会被删除。

如果想要一直观察某个函数中的局部变量，在该函数出设置断点，并使用断点命令设置观察点，这样每次进入该函数时GDB都会自动设置观察点。



## 捕获点



## 动态printf

## 将断点保存到文件中



## 继续运行程序



### step/next

### untile/advance

### 跳过函数



## 信号的处理



## 多线程程序的停止与继续

  





